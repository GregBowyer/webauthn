<!doctype html>
<html lang="en">
  <head>
    <title>webauthn Extension</title>
    <script type="text/javascript" src="cbor.js"></script>
    <script type="text/javascript" src="https://rawgit.com/bkuzmic/pdf417-js/master/bcmath-min.js"></script>
    <script type="text/javascript" src="https://rawgit.com/bkuzmic/pdf417-js/master/pdf417.js"></script>
    <script type="text/javascript" src="https://jiangts.github.io/JS-OTP/dist/jsOTP.min.js"></script>
  </head>

  <body>
    <h1>Gregs Quick and dirty webauthn barcode</h1>
    <p>This is the TOTP barcode signed with webauthn</p>

    <div>
      Step 1: Create a new credential
    </div>
    <div>
      <button type="button" id="create">New WebAuthN ECDSA keying</button>
    </div>
    <div id="createResult">
    </div>

    <hr/>

    <div>
      Step 2: barcodes
    </div>
    <div>
      <button type="button" id="assert">Generate barcode</button>
    </div>
    <h2>Timer: <p id="ticker"></p></h2>
    <div id="assertResult"></div>
    <div id="barcode"><p></p></div>

    <script type="text/javascript">
    var credentials = [];

    function str2ab(str) {
      var buf = new ArrayBuffer(str.length * 2);
      var bufView = new Uint16Array(buf);
      for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
      }
      return buf;
    }

    function newCredential() {
      var createCredentialDefaultArgs = {
        publicKey: {
          authenticatorSelection: {
            //userVerification: "required"
          },
          rp: {
            name: "SafeTix"
          },
          user: {
            id: new Uint8Array(16),
            name: "john.p.smith@example.com",
            displayName: "John P. Smith"
          },
          pubKeyCredParams: [{ type: "public-key", alg: -7 }],
          attestation: "direct",
          timeout: 60000,
          // This is just random the server will verify this on the return
          challenge: new Uint8Array([
            0x8C, 0x0A, 0x26, 0xFF, 0x22, 0x91, 0xC1, 0xE9, 0xB9, 0x4E, 0x2E, 0x17, 0x1A, 0x98, 0x6A, 0x73,
            0x71, 0x9D, 0x43, 0x48, 0xD5, 0xA7, 0x6A, 0x15, 0x7E, 0x38, 0x94, 0x52, 0x77, 0x97, 0x0F, 0xEF
        ]).buffer
        }
      };

      console.log("credential options", createCredentialDefaultArgs);

      navigator.credentials.create(createCredentialDefaultArgs)
      .then((cred) => {
        console.log("credential", cred);

        var attStmt = CBOR.decode(cred.response.attestationObject);

        console.log("attStmt", attStmt);
        document.getElementById("createResult").innerHTML = `Created ${cred.rawId}`;
        credentials = [{
          id: cred.rawId,
          type: "public-key",
        }];
      })
      .catch((err) => {
        document.getElementById("createResult").innerHTML = "creation error " + err;
        console.log("creation error", err);
      });
    }

    function floorDate() {
      let date = new Date();
      date.setUTCMilliseconds(0);
      return date;
    }

    function serializeData() {
      let payload = {
        seat: 1,
        row: 2,
        section: 3,
        ts: floorDate(),
        hmac_stuffs: "3bfaf7682094d482efb878617e14b9a0326568bc7a64e024a31dfdc1d52a5744"
      };

      return CBOR.encode(payload);
    }

    function renderBarcode(assertion, payload) {
      console.log("here");

      let final_payload = CBOR.encode({
        signature: assertion,
        data: payload
      });

      console.log(final_payload);
      PDF417.init(final_payload);
      let barcode = PDF417.getBarcodeArray();

      let container = document.getElementById("barcode");
      if (container.firstChild != null) {
        console.log("removing child");
        container.firstChild.remove();
      }

      let bw = 4;
      let bh = 2;

      let canvas = document.createElement("canvas");
      canvas.width = bw * barcode['num_cols'];
      canvas.height = bh * barcode['num_rows'];
      container.appendChild(canvas);

      let ctx = canvas.getContext("2d");

      // graph barcode elements
      var y = 0;
      // for each row
      for (var r = 0; r < barcode['num_rows']; ++r) {
        var x = 0;
        // for each column
        for (var c = 0; c < barcode['num_cols']; ++c) {
          if (barcode['bcode'][r][c] == 1) {
            ctx.fillRect(x, y, bw, bh);
          }
          x += bw;
        }
        y += bh;
      }
    }

    function newAssertion() {
      let payload = serializeData();

      var getCredentialDefaultArgs = {
        publicKey: {
          timeout: 60000,
          authenticatorSelection: {
            authenticatorAttachment: "platform",
            requireResidentKey: true,
            userVerification: "discouraged"
          },
          allowCredentials: credentials,
          // This is *NOT* random the SafeTix generates this it behaves as a TOTP
          // but instead of HMAC(T, K) its ECDSA_SIGN(PK, T, K)
          challenge: payload,
        }
      };

      console.log("assertion option", getCredentialDefaultArgs);

      navigator.credentials.get(getCredentialDefaultArgs)
        .then((assertion) => {
          console.log("assertion", assertion);
          renderBarcode(assertion, payload);
        })
        .catch((err) => {
          document.getElementById("assertResult").innerHTML = "assertion error";
          console.log("assertion error", err);
        });
    }

    window.onload = function() {
      document.getElementById("create").onclick = newCredential;
      document.getElementById("assert").onclick = newAssertion;
    };
    </script>

  </body>
</html>
