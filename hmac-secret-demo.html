<!doctype html>
<html lang="en">
  <head>
    <title>webauthn Extension</title>
    <script type="text/javascript" src="cbor.js"></script>
    <script type="text/javascript" src="bwip-js.js"></script>
  </head>

  <body>
    <h1>Gregs webauthn barcode PoC</h1>
    <p>This is the TOTP barcode signed with webauthn</p>

    <div>
      Step 1: Create a new credential
      This is only needed per ticket per device, it will persist in the browser
    </div>

    <div>
      <button type="button" id="create">New WebAuthN ECDSA key-pair</button>
    </div>
    <div id="createResult">
    </div>

    <hr/>

    <div>
      Step 2: barcodes
      Each barcode uses webauthn instead of totp to generate they still behave like totp and
      will die after 30-60 seconds
    </div>
    <div>
      <table cellpadding="0" cellspacing="1" border="0">
        <tbody>
          <tr>
            <th>Barcode Symbology: </th>
            <td>
              <select id="symbology">
                <option value="pdf417compact">Compact PDF417</option>
                <option value="pdf417">PDF417</option>
                <option value="azteccode">Aztec codes</option>
                <option value="datamatrix">Data Matrix</option>
                <option value="hanxin">HanXin codes</option>
                <option value="qrcode">QR Code</option>
              </select>
            </td>
          </tr>

          <tr>
            <th>Symbology Options: </th>
            <td>
              <input type="text" id="options"></input>
            </td>
          </tr>

          <tr>
            <th>Scale: </th>
            <td>
              <input type="text" id="scale" type="number" min="1" max="9" step="1" value="3"></input>
            </td>
          </tr>
        </tbody>
      </table>

      <button type="button" id="assert">Generate barcode</button>
    </div>

    <!--<h2>Timer: <p id="ticker"></p></h2>-->
    <div id="assertResult"></div>
    <div id="barcode"><p></p></div>

    <script type="text/javascript">
      try {
        let cred_id = localStorage.getItem('creds');
        document.getElementById("createResult").innerHTML = `Stored creds ${cred_id}`;
      } catch (err) {}

    function base64EncodeURL(byteArray) {
      return btoa(Array.from(new Uint8Array(byteArray)).map(val => {
        return String.fromCharCode(val);
      }).join('')).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    }

    function base64DecodeURL(b64urlstring) {
      return new Uint8Array(atob(b64urlstring.replace(/-/g, '+').replace(/_/g, '/')).split('').map(val => {
        return val.charCodeAt(0);
      }));
    }

    function newCredential() {
      var createCredentialDefaultArgs = {
        publicKey: {
          authenticatorSelection: {
            authenticatorAttachment: "platform",
            requireResidentKey: true,
            userVerification: "required",
          },
          rp: {
            name: "SafeTix"
          },
          user: {
            id: new Uint8Array(16),
            name: "john.p.smith@example.com",
            displayName: "John P. Smith"
          },
          pubKeyCredParams: [{ type: "public-key", alg: -7 }],
          attestation: "direct",
          timeout: 60000,
          // This is just random the server will verify this on the return
          challenge: new Uint8Array([
            0x8C, 0x0A, 0x26, 0xFF, 0x22, 0x91, 0xC1, 0xE9, 0xB9, 0x4E, 0x2E, 0x17, 0x1A, 0x98, 0x6A, 0x73,
            0x71, 0x9D, 0x43, 0x48, 0xD5, 0xA7, 0x6A, 0x15, 0x7E, 0x38, 0x94, 0x52, 0x77, 0x97, 0x0F, 0xEF
        ]).buffer
        }
      };

      console.log("credential options", createCredentialDefaultArgs);

      navigator.credentials.create(createCredentialDefaultArgs)
      .then((cred) => {
        console.log("credential", cred);

        var attStmt = CBOR.decode(cred.response.attestationObject);

        console.log("attStmt", attStmt);
        document.getElementById("createResult").innerHTML = `Created ${cred.id}`;
        localStorage.setItem('creds', cred.id);
      })
      .catch((err) => {
        document.getElementById("createResult").innerHTML = "creation error " + err;
        console.log("creation error", err);
      });
    }

    function floorDate() {
      let date = new Date();
      date.setUTCMilliseconds(0);
      return date;
    }

    // A fake payload just to have some data
    function serializeData() {
      let payload = {
        seat: 1,
        row: 2,
        section: 3,
        ts: floorDate(),
        hmac_stuffs: "3bfaf7682094d482efb878617e14b9a0326568bc7a64e024a31dfdc1d52a5744"
      };

      return CBOR.encode(payload);
    }

    function renderBarcode(assertion, payload) {
      console.log("here");

      // We should encode with CBOR or some binary method
      let final_payload = JSON.stringify({
        signature: base64EncodeURL(assertion.response.signature),
        data: base64EncodeURL(payload)
      });

      console.log(final_payload);

      let container = document.getElementById("barcode");
      if (container.firstChild != null) {
        console.log("removing child");
        container.firstChild.remove();
      }

      let bw = 4;
      let bh = 2;

      let symbology = document.getElementById('symbology').value;
      let scale = document.getElementById('scale').value;
      let options = document.getElementById('options').value;

      // Convert the options to an object.
      let opts = {
        bcid: symbology,
        text: final_payload,
        scale: scale,
        includetext: false,
        textxalign: 'center',
        backgroundcolor: 'FFFFFF',
        padding: 10,
      };

      let aopts = options.split(' ');
      for (let i = 0; i < aopts.length; i++) {
        var eq = aopts[i].indexOf('=');
        if (eq == -1) {
          opts[aopts[i]] = true;
        } else {
          opts[aopts[i].substr(0, eq)] = aopts[i].substr(eq+1);
        }
      }

      let bar_canvas = document.createElement('canvas');
      let canvas = bwipjs.toCanvas(bar_canvas, opts);
      container.appendChild(bar_canvas);
    }

    function newAssertion() {
      let payload = serializeData();

      let cred_id = localStorage.getItem('creds');
      console.log(cred_id);
      console.log(base64DecodeURL(cred_id));
      console.log(base64EncodeURL(base64DecodeURL(cred_id)));

      var getCredentialDefaultArgs = {
        publicKey: {
          timeout: 60000,
          authenticatorSelection: {
            authenticatorAttachment: "platform",
            requireResidentKey: true,
            userVerification: "discouraged"
          },
          allowCredentials: [{
            id: base64DecodeURL(cred_id),
            type: "public-key",
          }],

          // This is *NOT* random the SafeTix generates this it behaves as a TOTP
          // but instead of HMAC(T, K) its ECDSA_SIGN(PK, T, K)
          challenge: payload,
        }
      };

      console.log("assertion option", getCredentialDefaultArgs);

      navigator.credentials.get(getCredentialDefaultArgs)
        .then((assertion) => {
          console.log("assertion", assertion);
          renderBarcode(assertion, payload);
        })
        .catch((err) => {
          console.error("assertion error", err);
          document.getElementById("assertResult").innerHTML = `assertion error: ${err}`;
        });
    }

    window.onload = function() {
      document.getElementById("create").onclick = newCredential;
      document.getElementById("assert").onclick = newAssertion;
    };
    </script>

  </body>
</html>
